/************* 快速幂 ****************/

算法流程及原理:
	对n进行二进制分解，保存两个数tmp是当前的a的幂级，ret为已经算出来的结果，每次取n的一位二进制，如果是1，则表示当前位需要多补充一个tmp，即乘上tmp，否则，无须处理。最后ret为答案。

测试数据及其输出结果:

/*** calc a^n (mod p) ***/
a = 3
n = 7
p = 10 
7

/************* 厄拉多塞筛法 ****************/

算法流程及原理:
	循环从1-n的过程中, 每次遇到一个素数, 将它的倍数标记为偶数, 可以得到所有素数.

测试数据及其输出结果:

/*** Get the Primes ***/
Get Primes smaller or euqal to : 100
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]


/************* 扩展欧几里得算法 ****************/

算法流程:
        在gcd中进行迭代计算 ax+by=r
        a=bq1+r1        r1=ax1+by1
        b=r1q2+r2       r2=ax2+by2
        r2=r2q3+r3      r3=ax3+by3
        ...             ...
        rn-2=rn-1qn+rn  rn=axn+byn
        rn-1=rnqn+1+0

测试数据及其输出结果:

/*** Exgcd Algorithm : calc a*x + b*y = (a, b) ***/
a = 19
b = 23
x = -6 y = 5 (a, b) = 1

/************* 费马素性判定 ****************/

算法流程及原理：
	1. 读入10个整数，并给定安全参数T，开始处理
	2. 若数字x为1特判False，若有对于 mod 2或3 == 0 的整数输出No，
	3. 随机选取整数ran在[2, x-2]，计算 ret = ran^x mod (x-1)
	4. 若ret!=1，则返回x为合数
	5. 2-4过程重复T次

测试数据及其输出结果:

/*** Fermat Prime Test ***/
Test for x : 117   
Test times : 1000
This isn't a prime

/************* 中国剩余定理 ****************/

算法流程:
	M = m1 * m2 ... * m10
	Mi = M / mi
	利用扩展欧几里得算法计算 Mi', 其中MiMi'* M = 1 (mod mi)	
	对于每一项i, 值为 xi = bi * Mi * Mi'
	有：
		xi = bi * Mi * Mi' (mod mi) = bi * 1 (mod mi) = bi (mod mi)
		xi = bi * Mi * Mi' (mod mj) = bi * Mi' * Mi (mod mj) = 0 (mod mj) 其中(j != i)
	保证每一项在笛卡尔系下能够独立，不受其他同余模数的影响。
	
	最后答案就是 ans = (x1 + x2 + ... + x10) mod M


测试数据及其输出结果:

/*** C.R.T ***/
Equation Number : 4
x = r1 (mod m1)
r1 = 10
m1 = 31
x = r2 (mod m2)
r2 = 21
m2 = 45
x = r3 (mod m3)
r3 = 11
m3 = 17
x = r4 (mod m4)
r4 = 10
m4 = 29
x = 435126


/************** Solovay_Stassen素性判定 ****************/

算法原理:
	根据欧拉判别条件，若p为奇素数，对于任意数(a, p)=1，也就是a !=0 有a^((p-1)/2) = 1或-1
	此外，若p为奇素数，Jacobi(a, p) = Legendre(a, p) = a^((p-1)/2) (mod p)
	
算法流程:
	利用前面的快速幂算法与Jacobi计算算法可以计算出对应的两个值，进行比较即可。

测试数据及其输出结果:

/*** Solovay_Stassen Prime Test ***/
Test for x : 1117
Test Times : 1000
This is a prime

/************* Miller-Rabin素性检验 ****************/

算法流程及原理:
	对于一个数n，若n为素数
	有对于任何数有 a^(n-1)-1=(a^(2^(s-1)*t)+1) * (a^(2^(s-2)*t)+1) * ... * (a^t+1) * (a^t-1) = 0，也就是说以下同余式至少有一个成立：
		a^t          =  1 	(mod n)
		a^t          = -1	(mod n)
		a^(2t) 	     = -1	(mod n)
		...
		a^(2^(s-1)t) = -1	(mod n)
优化：
	计算2^s: 利用二进制运算 2^s = n & (~n+1)
	计算a^t: 利用快速幂计算
	初始时，判断r0 = a^t是否为1或-1则直接返回可能是素数
	算的过程中，如果ri = a^(2^i*t)若为-1直接返回可能是素数，如果ri为1则直接返回不可能是素数，因为ri之后r一定依然是1，故不可能存在-1。

测试数据及其输出结果:

/*** Miller-Rabin Prime Test ***/
Test X : 1111117
Test Times : 100
This isn't a Prime


/************* 有限域为2的扩展欧几里德算法 ****************/

算法原理:
	算法与整数域的扩展欧几里德算法原理相同:
        在gcd中进行迭代计算 ax+by=r
        a=bq1+r1        r1=ax1+by1
        b=r1q2+r2       r2=ax2+by2
        r2=r2q3+r3      r3=ax3+by3
        ...             ...
        rn-2=rn-1qn+rn  rn=axn+byn
        rn-1=rnqn+1+0

算法流程:
	利用sage对整系数多项式的支持 + - * / % 操作进行非递归扩展欧几里德算法

测试数据及其输出结果:

/****** Exgcd on GF(2^n) *******/
please input like '0 1 1' which means x^1 + x^2
calc : f * X + g * Y = (f, g)
multinomial f: 
1 0 1
multinomial g: 
0 1
(f: x^2 + 1) * (1) + (g: x) * (x) = 1


心得体会:
	有效复习了现在对于之前算法的忘却, 对这些算法能够重新温故一遍, 并且对有限域的理解有所加深. 
	感觉对于sage软件的强大叹为观止, 然而利用的却是其中的一小部分
	对于有限域感觉实现起来代码量巨大, 取巧利用了 sage 当中对有限域GF(2)下的多项式的支持.


